name: Base system install for CHESS software stack (reusable)

on:
  workflow_call:
    inputs:
      install-prefix:
        description: 'Install prefix for CHESS software stack.'
        required: false
        type: string
        default: ''

      runner:
        description: 'Runner label (e.g. ubuntu-latest, macos-latest)'
        type: string
        required: false
        default: ubuntu-latest

      enable_mutationpp:
        description: 'Build and install Mutation++ (C++ + Python)'
        required: false
        type: boolean
        default: true

      enable_precice:
        description: 'Build and install preCICE (with PETSc & Python)'
        required: false
        type: boolean
        default: true

      enable_sundials:
        description: 'Build and install SUNDIALS'
        required: false
        type: boolean
        default: true

      enable_adios2:
        description: 'Build and install ADIOS2'
        required: false
        type: boolean
        default: true

      enable_mfem:
        description: 'Build and install MFEM'
        required: false
        type: boolean
        default: true

      build_label:
        required: false
        type: string
        description: 'Human readable build name (shown in UI)'

    outputs:
      build_name:
        description: 'BUILD_NAME used for artifacts'
        value: ${{ jobs.build.outputs.build_name }}

jobs:
  build:
    name: ${{ inputs.build_label || inputs.runner }}
    runs-on: ${{ inputs.runner }}

    outputs:
      build_name: ${{ steps.build-name.outputs.build_name }}

    env:
      OMPI_MCA_rmaps_base_oversubscribe: "1"
      CMAKE_BUILD_TYPE: Release

      # Global CHESS software install path
      CHESS_STACK_PREFIX: ${{ inputs.install-prefix != '' && inputs.install-prefix || format('{0}/chess-software', github.workspace) }}

      # Mutation++ paths
      MPP_SRC: ${{ github.workspace }}/Mutationpp
      MPP_BUILD: ${{ github.workspace }}/build/mpp
      MPP_PY_BUILD: ${{ github.workspace }}/build/mpp-py
      PYTHON_ABI: py312   # Keep this in sync with the runner's Python major.minor

      # preCICE paths
      PRECICE_SRC: ${{ github.workspace }}/precice
      PRECICE_BUILD: ${{ github.workspace }}/build/precice

      # SUNDIALS paths
      SUNDIALS_SRC:    ${{ github.workspace }}/sundials
      SUNDIALS_BUILD:  ${{ github.workspace }}/build/sundials

      # MFEM paths 
      MFEM_SRC:      ${{ github.workspace }}/mfem
      MFEM_BUILD:    ${{ github.workspace }}/build/mfem

      # ADIOS2 paths
      ADIOS2_SRC:    ${{ github.workspace }}/adios2
      ADIOS2_BUILD:  ${{ github.workspace }}/build/adios2

      # GKlib paths (dependency of METIS)
      GKLIB_SRC:    ${{ github.workspace }}/GKlib

      # METIS paths (we will build METIS 5 from source)
      METIS_SRC:     ${{ github.workspace }}/metis
      METIS_BUILD:   ${{ github.workspace }}/build/metis

      # hypre paths
      HYPRE_SRC:    ${{ github.workspace }}/hypre
      HYPRE_BUILD:  ${{ github.workspace }}/build/hypre

      # Feature toggles for this stack build
      USE_MPP: ${{ inputs.enable_mutationpp }}
      USE_PRECICE: ${{ inputs.enable_precice }}
      USE_SUNDIALS: ${{ inputs.enable_sundials }}
      USE_MFEM: ${{ inputs.enable_mfem }}
      USE_ADIOS2:    ${{ inputs.enable_adios2 }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Process configuration / build name
        id: build-name
        run: |
          if [ -n "${{ inputs.build_label }}" ]; then
            echo "Using caller-specified build_label for BUILD_NAME"
            name="${{ inputs.build_label }}"
          else
            echo "Conjuring BUILD_NAME from runner and enabled deps"
            name="${{ inputs.runner }}"
            if [ "${{ inputs.enable_mutationpp }}" = "true" ]; then
              name="${name:+$name-}mpp"
            fi
            if [ "${{ inputs.enable_precice }}" = "true" ]; then
              name="${name:+$name-}precice"
            fi
            [ -z "${name}" ] && name="base"
          fi

          BUILD_NAME=$name
          echo "BUILD_NAME=$name" >> "$GITHUB_ENV"
          echo "build_name=$name" >> "$GITHUB_OUTPUT"

          echo "Runner:        ${{ inputs.runner }}"
          echo "Build label:   ${{ inputs.build_label }}"
          echo "Build name:    $BUILD_NAME"

          printf "Mutation++: "
          if [ "${{ inputs.enable_mutationpp }}" = "true" ]; then
            printf "ON\n"
          else
            printf "OFF\n"
          fi

          printf "preCICE:    "
          if [ "${{ inputs.enable_precice }}" = "true" ]; then
            printf "ON\n"
          else
            printf "OFF\n"
          fi

      - name: Initial CHESS stack prefix setup
        run: |
          set -eux
          mkdir -p "${CHESS_STACK_PREFIX}"
          echo "CHESS_STACK_PREFIX=${CHESS_STACK_PREFIX}" >> "$GITHUB_ENV"
          echo "LD_LIBRARY_PATH=${CHESS_STACK_PREFIX}/lib:${CHESS_STACK_PREFIX}/lib64:${LD_LIBRARY_PATH:-}" >> "$GITHUB_ENV" 
          echo "PATH=${CHESS_STACK_PREFIX}/bin:${PATH}" >> "$GITHUB_ENV"
          echo "CMAKE_PREFIX_PATH=${CHESS_STACK_PREFIX}:${CMAKE_PREFIX_PATH:-}" >> "$GITHUB_ENV"
          echo "PKG_CONFIG_PATH=${CHESS_STACK_PREFIX}/lib/pkgconfig:${CHESS_STACK_PREFIX}/lib64/pkgconfig:${PKG_CONFIG_PATH:-}" >> "$GITHUB_ENV"
          echo "CPATH=${CHESS_STACK_PREFIX}/include:${CPATH:-}" >> "$GITHUB_ENV"
          echo "PYTHONPATH=${CHESS_STACK_PREFIX}:${PYTHONPATH:-}" >> "$GITHUB_ENV"

      - name: Install Linux build-time system (${{ env.BUILD_NAME }})
        if: ${{ runner.os == 'Linux' }}
        # PETSc package atuomatically drags in MPI, HDF5, BLAS/LAPACK, etc
        run: |
          set -eux

          sudo apt-get update
          sudo apt-get install -y \
            gfortran gcc g++ libboost-all-dev \
            make automake autoconf libtool pkg-config \
            petsc-dev cmake ninja-build libeigen3-dev \
            libblas-dev liblapack-dev \
            libhdf5-openmpi-dev \
            libhypre-dev libmetis-dev \
            python3 python3-pip python3-dev python3-venv \
            wget

          python3 -m pip install --upgrade pip
          python3 -m pip install numpy scipy matplotlib
          python3 -m pip install -U setuptools wheel scikit-build ninja

          mpif90 -show || true
          mpicc  -show || true

          # Expose Eigen to downstream CMake builds
          echo "EIGEN3_INCLUDE_DIR=/usr/include/eigen3" >> "$GITHUB_ENV"
          echo "CPATH=/usr/include/eigen3:${CPATH:-}" >> "$GITHUB_ENV"

      - name: Install macOS build-time system (${{ env.BUILD_NAME }})
        if: ${{ runner.os == 'macOS' }}
        run: |
          set -eux

          brew update
          brew install \
            gcc boost \
            automake autoconf libtool pkg-config \
            cmake ninja eigen \
            open-mpi hdf5 petsc wget

          python3 -m pip install --upgrade pip
          python3 -m pip install numpy scipy matplotlib
          python3 -m pip install -U setuptools wheel scikit-build ninja

          mpif90 -show || true
          mpicc  -show || true

          # Expose Eigen to downstream CMake builds on macOS
          EIGEN_PREFIX="$(brew --prefix eigen)"
          echo "EIGEN3_INCLUDE_DIR=${EIGEN_PREFIX}/include/eigen3" >> "$GITHUB_ENV"
          echo "CPATH=${EIGEN_PREFIX}/include/eigen3:${CPATH:-}" >> "$GITHUB_ENV"
          echo "CMAKE_PREFIX_PATH=${EIGEN_PREFIX}:${CMAKE_PREFIX_PATH:-}" >> "$GITHUB_ENV"

      - name: Housekeeping for Linux PETSc install
        if: ${{ runner.os == 'Linux' }}
        run: |
          set -eux

          echo "=== Searching for PETSc petscvariables under /usr/lib ==="
          find /usr/lib/petscdir -maxdepth 8 -type f \
            \( -name 'petscvariables' -o -name 'variables' \) -print || true

          PETSC_VAR_FILE=$(find /usr/lib/petscdir -maxdepth 8 -type f -path '*lib/petsc/conf/petscvariables' | head -n 1 || true)

          if [ -z "${PETSC_VAR_FILE}" ]; then
            echo "ERROR: Could not find petscvariables under /usr/lib/petscdir"
            exit 1
          fi

          echo "Found PETSC_VAR_FILE=${PETSC_VAR_FILE}"

          # Strip the known suffix to get PETSC_DIR:
          #   PETSC_VAR_FILE = PETSC_DIR/lib/petsc/conf/petscvariables
          PETSC_DIR="${PETSC_VAR_FILE%/lib/petsc/conf/petscvariables}"

          echo "Derived PETSC_DIR=${PETSC_DIR}"

          # Sanity check
          if [ ! -f "${PETSC_DIR}/lib/petsc/conf/petscvariables" ]; then
            echo "ERROR: Derived PETSC_DIR does not contain lib/petsc/conf/petscvariables"
            ls -l "${PETSC_DIR}/lib/petsc/conf" || true
            exit 1
          fi

          # Export for later steps
          echo "PETSC_DIR=${PETSC_DIR}" >> "$GITHUB_ENV"

          # PETSc was linked against system BLAS/LAPACK, but its variables
          # still request -lflapack -lfblas.  Add symlinks so the names resolve.
          sudo ln -sf /usr/lib/x86_64-linux-gnu/liblapack.so /usr/lib/x86_64-linux-gnu/libflapack.so
          sudo ln -sf /usr/lib/x86_64-linux-gnu/libblas.so   /usr/lib/x86_64-linux-gnu/libfblas.so

      - name: Housekeeping for Linux HDF5 install
        if: ${{ runner.os == 'Linux' }}
        run: |
          set -eux

          if ! command -v h5pcc >/dev/null 2>&1; then
            echo "ERROR: h5pcc not found; make sure libhdf5-openmpi-dev is installed."
            exit 1
          fi

          echo "=== h5pcc -showconfig ==="
          h5pcc -showconfig || true

          # Crude but effective: extract first -I and -L from h5pcc -show
          H5_SHOW="$(h5pcc -show)"
          HDF5_INCDIR=$(echo "${H5_SHOW}" | tr ' ' '\n' | grep '^-I' | head -n1 | sed 's/^-I//')
          HDF5_LIBDIR=$(echo "${H5_SHOW}" | tr ' ' '\n' | grep '^-L' | head -n1 | sed 's/^-L//')

          if [ -z "${HDF5_INCDIR}" ] || [ -z "${HDF5_LIBDIR}" ]; then
            echo "ERROR: Could not parse HDF5 include/lib dirs from h5pcc -show."
            echo "${H5_SHOW}"
            exit 1
          fi

          echo "Detected HDF5_INCDIR=${HDF5_INCDIR}"
          echo "Detected HDF5_LIBDIR=${HDF5_LIBDIR}"

          # Build a synthetic prefix that matches CGNS's expectation: prefix/include, prefix/lib
          # HDF5_DIR="$HOME/hdf5-prefix"
          HDF5_DIR="${CHESS_STACK_PREFIX}"
          mkdir -p "${HDF5_DIR}/include" "${HDF5_DIR}/lib" "${HDF5_DIR}/bin"
          ln -sf "${HDF5_INCDIR}"/* "${HDF5_DIR}/include/"
          ln -sf "${HDF5_LIBDIR}"/* "${HDF5_DIR}/lib/"
          ln -sf /usr/bin/h5* "${HDF5_DIR}/bin/"

          echo "Using HDF5_DIR=${HDF5_DIR} as CGNS prefix"

          {
            echo "HDF5_DIR=${HDF5_DIR}"
            echo "HDF5_INCDIR=${HDF5_DIR}/include"
            echo "HDF5_LIBDIR=${HDF5_DIR}/lib"
          } >> "$GITHUB_ENV"

      - name: Build CGNS (parallel, with HDF5)
        if: ${{ runner.os == 'Linux' }}
        run: |
          set -eux
          : "${HDF5_DIR:?HDF5_DIR not set}"
          : "${HDF5_INCDIR:?HDF5_INCDIR not set}"
          : "${HDF5_LIBDIR:?HDF5_LIBDIR not set}"

          CGNS_VERSION=4.5.0
          cd "$HOME"
          if [ ! -f "v${CGNS_VERSION}.tar.gz" ]; then
            wget -q "https://github.com/CGNS/CGNS/archive/refs/tags/v${CGNS_VERSION}.tar.gz"
          fi
          rm -rf "CGNS-${CGNS_VERSION}"
          tar -xzf "v${CGNS_VERSION}.tar.gz"

          cd "CGNS-${CGNS_VERSION}/src"

          ./configure \
            FC=mpif90 \
            CC=mpicc \
            CXX=mpicxx \
            --enable-64bit \
            --with-fortran \
            --enable-parallel \
            --with-hdf5="${HDF5_DIR}" \
            --prefix="${CHESS_STACK_PREFIX}"

          make
          make install

          echo "CGNS_DIR=${CHESS_STACK_PREFIX}" >> "$GITHUB_ENV"
          # echo "LD_LIBRARY_PATH=${CHESS_STACK_PREFIX}/lib:${LD_LIBRARY_PATH:-}" >> "$GITHUB_ENV"

      - name: Build SUNDIALS (Linux)
        if: ${{ runner.os == 'Linux' && env.USE_SUNDIALS == 'true' }}
        run: |
          set -eux

          SUNDIALS_VERSION=7.5.0
          SUNDIALS_TAR="sundials-${SUNDIALS_VERSION}.tar.gz"
          SUNDIALS_URL="https://github.com/LLNL/sundials/releases/download/v${SUNDIALS_VERSION}/${SUNDIALS_TAR}"

          mkdir -p "${SUNDIALS_BUILD}" "${CHESS_STACK_PREFIX}"
          cd "${HOME}"

          if [ ! -f "${SUNDIALS_TAR}" ]; then
            wget -q "${SUNDIALS_URL}"
          fi

          rm -rf "sundials-${SUNDIALS_VERSION}"
          tar -xzf "${SUNDIALS_TAR}"

          cmake -S "sundials-${SUNDIALS_VERSION}" -B "${SUNDIALS_BUILD}" \
            -G Ninja \
            -DCMAKE_BUILD_TYPE="${CMAKE_BUILD_TYPE}" \
            -DCMAKE_INSTALL_PREFIX="${CHESS_STACK_PREFIX}" \
            -DBUILD_SHARED_LIBS=ON \
            -DEXAMPLES_ENABLE_C=OFF \
            -DEXAMPLES_ENABLE_CXX=OFF \
            -DEXAMPLES_ENABLE_F77=OFF \
            -DEXAMPLES_ENABLE_F90=OFF \
            -DMPI_ENABLE=ON \
            -DOPENMP_ENABLE=OFF \
            -DKLU_ENABLE=OFF \
            -DLAPACK_ENABLE=ON \
            -DBLAS_ENABLE=ON

          cmake --build "${SUNDIALS_BUILD}" \
            --config "${CMAKE_BUILD_TYPE}" \
            --target install -- -j"$(nproc || echo 2)"

          echo "SUNDIALS_DIR=${CHESS_STACK_PREFIX}" >> "$GITHUB_ENV"

      - name: Clone ADIOS2
        if: ${{ runner.os == 'Linux' && env.USE_ADIOS2 == 'true' }}
        run: |
          set -eux
          : "${ADIOS2_REF:=v2.10.1}"   # pin to this version
          git clone https://github.com/ornladios/ADIOS2.git "${ADIOS2_SRC}"
          cd "${ADIOS2_SRC}"
          git checkout "${ADIOS2_REF}"

      - name: Get ADIOS2 commit hash
        if: ${{ runner.os == 'Linux' && env.USE_ADIOS2 == 'true' }}
        id: adios2sha
        run: |
          set -eux
          cd "${ADIOS2_SRC}"
          echo "adios2_sha=$(git rev-parse HEAD)" >> "$GITHUB_OUTPUT"

      - name: Cache ADIOS2 build
        if: ${{ runner.os == 'Linux' && env.USE_ADIOS2 == 'true' }}
        id: cache-adios2
        uses: actions/cache@v4
        with:
          path: ${{ env.ADIOS2_BUILD }}
          key: ${{ runner.os }}-adios2-${{ steps.adios2sha.outputs.adios2_sha }}-${{ env.BUILD_NAME }}-${{ env.CMAKE_BUILD_TYPE }}

      - name: Build ADIOS2 (MPI-enabled)
        if: ${{ runner.os == 'Linux' && env.USE_ADIOS2 == 'true' }}
        run: |
          set -eux

          mkdir -p "${ADIOS2_BUILD}" "${CHESS_STACK_PREFIX}"

          if [ ! -f "${ADIOS2_BUILD}/CMakeCache.txt" ]; then
            cmake -S "${ADIOS2_SRC}" -B "${ADIOS2_BUILD}" \
              -G Ninja \
              -DCMAKE_BUILD_TYPE="${CMAKE_BUILD_TYPE}" \
              -DCMAKE_INSTALL_PREFIX="${CHESS_STACK_PREFIX}" \
              -DADIOS2_USE_MPI=ON \
              -DADIOS2_BUILD_EXAMPLES=OFF \
              -DADIOS2_BUILD_TESTING=OFF \
              -DADIOS2_BUILD_PYTHON=OFF
          fi

          cmake --build "${ADIOS2_BUILD}" \
            --config "${CMAKE_BUILD_TYPE}" \
            --target install -- -j"$(nproc || echo 2)"

      - name: Configure ADIOS2 environment
        if: ${{ runner.os == 'Linux' && env.USE_ADIOS2 == 'true' }}
        run: |
          set -eux
          echo "ADIOS2_DIR=${CHESS_STACK_PREFIX}" >> "$GITHUB_ENV"

      # ---- Mutation++ (C++ library only) -----------------------------------
      - name: Clone Mutation++
        if: ${{ env.USE_MPP == 'true' }}
        run: |
          set -eux
          git clone --depth 1 https://github.com/mutationpp/Mutationpp.git "${MPP_SRC}"

      - name: Get Mutation++ commit hash
        if: ${{ env.USE_MPP == 'true' }}
        id: mppsha
        run: |
          set -eux
          echo "mpp_sha=$(git -C "${MPP_SRC}" rev-parse HEAD)" >> "$GITHUB_OUTPUT"

      - name: Cache Mutation++ install
        if: ${{ env.USE_MPP == 'true' }}
        id: cache-mpp
        uses: actions/cache@v4
        with:
          path: ${{ env.MPP_BUILD }}
          key: ${{ runner.os }}-mpp-${{ steps.mppsha.outputs.mpp_sha }}-${{ env.CMAKE_BUILD_TYPE }}

      - name: Build & install Mutation++ (C++)
        if: ${{ env.USE_MPP == 'true' }}
        run: |
          set -eux
          if [ ! -f "${MPP_BUILD}/CMakeCache.txt" ]; then
            cmake -S "${MPP_SRC}" -B "${MPP_BUILD}" \
              -G Ninja \
              -DCMAKE_BUILD_TYPE="${CMAKE_BUILD_TYPE}" \
              -DCMAKE_INSTALL_PREFIX="${CHESS_STACK_PREFIX}"
          fi
          cmake --build "${MPP_BUILD}" --config "${CMAKE_BUILD_TYPE}" --target install -- -v

      - name: Configure Mutation++ environment
        if: ${{ env.USE_MPP == 'true' }}
        run: |
          set -eux
          echo "MPP_DIRECTORY=${MPP_SRC}" >> "$GITHUB_ENV"
          echo "MPP_DATA_DIRECTORY=${MPP_SRC}/data" >> "$GITHUB_ENV"
          # echo "PATH=${CHESS_STACK_PREFIX}/bin:${PATH}" >> "$GITHUB_ENV"

          if [[ -d "${CHESS_STACK_PREFIX}/lib64" ]]; then LIBDIR=lib64; else LIBDIR=lib; fi
          echo "MPP_LIBDIR=${LIBDIR}" >> "$GITHUB_ENV"

      - name: Cache Mutation++ Python bindings
        if: ${{ env.USE_MPP == 'true' }}
        id: cache-mpp-py
        uses: actions/cache@v4
        with:
          path: ${{ env.CHESS_STACK_PREFIX }}/pympp
          key: ${{ runner.os }}-mpp-py-${{ steps.mppsha.outputs.mpp_sha }}-${{ env.PYTHON_ABI }}

      - name: Install Mutation++ Python bindings
        if: ${{ env.USE_MPP == 'true' && steps.cache-mpp-py.outputs.cache-hit != 'true' }}
        env:
          # Needed to work around project settings
          CMAKE_ARGS: -DCMAKE_POLICY_VERSION_MINIMUM=3.5
        run: |
          set -eux
          cmake --version

          # Make sure the target directory exists
          mkdir -p "${CHESS_STACK_PREFIX}/pympp"

          # First try with normal build isolation
          set +e
          python3 -m pip install "${MPP_SRC}" \
            --target "${CHESS_STACK_PREFIX}/pympp" \
            --verbose
          status=$?
          set -e

          # If that fails, try no build isolation
          if [ $status -ne 0 ]; then
            echo "First pip install attempt failed with exit code $status. Retrying with --no-build-isolation..."
            python3 -m pip install "${MPP_SRC}" \
              --no-build-isolation \
              --target "${CHESS_STACK_PREFIX}/pympp" \
              --verbose
          fi

      - name: Configure Python path for Mutation++
        if: ${{ env.USE_MPP == 'true' }}
        run: |
          set -eux
          echo "PYTHONPATH=${CHESS_STACK_PREFIX}/pympp:${PYTHONPATH:-}" >> "$GITHUB_ENV"

      - name: Verify Mutation++ Python import
        if: ${{ env.USE_MPP == 'true' }}
        run: |
          set -eux
          python3 - <<'EOF'
          import os
          print("MPP_DIRECTORY:", os.environ.get("MPP_DIRECTORY"))
          print("MPP_DATA_DIRECTORY:", os.environ.get("MPP_DATA_DIRECTORY"))

          import mutationpp as mpp
          print("mutationpp imported OK from:", mpp.__file__)
          EOF

      - name: Print Mutation++ environment
        if: ${{ env.USE_MPP == 'true' }}
        run: |
          echo "MPP_DIRECTORY=$MPP_DIRECTORY"
          echo "MPP_DATA_DIRECTORY=$MPP_DATA_DIRECTORY"
          echo "Using libdir: $MPP_LIBDIR"
          echo "PATH=$PATH"
          echo "LD_LIBRARY_PATH=${LD_LIBRARY_PATH:-}"
          echo "CMAKE_PREFIX_PATH=${CMAKE_PREFIX_PATH:-}"
          echo "PKG_CONFIG_PATH=${PKG_CONFIG_PATH:-}"
          echo "Python executable: $(command -v python3)"
          python3 -V || true
          echo "Python sys.path:"
          python3 - <<'EOF' || true
          import sys
          for p in sys.path:
              print("  ", p)
          EOF

          echo "Installed mutationpp info (if available):"
          python3 - <<'EOF' || true
          try:
              import mutationpp as mpp
              print("  mutationpp imported OK from:", mpp.__file__)
          except Exception as e:
              print("  mutationpp import failed:", e)
          EOF

      # ---- preCICE ---------------------------------------------------------
      - name: Clone preCICE
        if: ${{ env.USE_PRECICE == 'true' }}
        run: |
          set -eux
          git clone -b release-v2.5.0 https://github.com/precice/precice.git "${PRECICE_SRC}"
          cd "${PRECICE_SRC}"

      - name: Cache preCICE build
        if: ${{ env.USE_PRECICE == 'true' }}
        id: cache-precice
        uses: actions/cache@v4
        with:
          path: ${{ env.PRECICE_BUILD }}
          key: ${{ runner.os }}-precice-v2_5_0-${{ env.CMAKE_BUILD_TYPE }}

      - name: Build & install preCICE (with PETSc + Python)
        if: ${{ env.USE_PRECICE == 'true' }}
        run: |
          set -eux

          if [ ! -f "${PRECICE_BUILD}/CMakeCache.txt" ]; then
            cmake -S "${PRECICE_SRC}" -B "${PRECICE_BUILD}" \
              -DCMAKE_BUILD_TYPE="${CMAKE_BUILD_TYPE}" \
              -DBUILD_SHARED_LIBS=ON \
              -DPRECICE_PythonActions=ON \
              -DPRECICE_PETScMapping=ON \
              -DPETSC_DIR="${PETSC_DIR:-}" \
              -DPYTHON_EXECUTABLE="$(command -v python3)" \
              -DCMAKE_C_COMPILER=mpicc \
              -DCMAKE_Fortran_COMPILER=mpif90 \
              -DCMAKE_CXX_COMPILER=mpicxx \
              -DCMAKE_INSTALL_PREFIX="${CHESS_STACK_PREFIX}"
          fi

          cmake --build "${PRECICE_BUILD}" \
            --config "${CMAKE_BUILD_TYPE}" \
            --target install -- -j"$(nproc || echo 2)"

      - name: Configure and inspect preCICE environment
        if: ${{ env.USE_PRECICE == 'true' }}
        run: |
          set -eux
          ls -latR ${CHESS_STACK_PREFIX}
          echo "PRECICE_DIR=${CHESS_STACK_PREFIX}" >> "$GITHUB_ENV"
          echo "CHESS_STACK_PREFIX=$CHESS_STACK_PREFIX"
          echo "PATH=$PATH"
          echo "LD_LIBRARY_PATH=${LD_LIBRARY_PATH:-}"
          echo "PKG_CONFIG_PATH=${PKG_CONFIG_PATH:-}"
          echo "CMAKE_PREFIX_PATH=${CMAKE_PREFIX_PATH:-}"

      - name: Check preCICE installation using Fortran
        if: ${{ env.USE_PRECICE == 'true' }}
        run: |
          set -eux

          cat > precice_test.F90 << 'EOF'
            program precicetest
              implicit none
              integer, parameter   :: str_l = 50
              integer              :: rank, commsize, dt, numberOfVertices
              character(len=str_l) :: participantName, config
              external             :: precicef_create, precicef_finalize
              rank     = 0
              commsize = 1
              dt       = 1
              numberOfVertices = 3
              participantName  = 'SolverOne'
              config           = 'precice-config.xml'
              call precicef_create(participantName, config, rank, commsize)
              call precicef_finalize()
            end program precicetest
          EOF

          mpif90 -o precice_test precice_test.F90 \
            -I"${CHESS_STACK_PREFIX}/include" \
            -L"${CHESS_STACK_PREFIX}/lib" -lprecice

          echo "Manual preCICE Fortran test linked successfully."

      - name: Clone GKlib
        if: ${{ runner.os == 'Linux' && env.USE_MFEM == 'true' }}
        run: |
          set -eux
          git clone https://github.com/KarypisLab/GKlib.git "${GKLIB_SRC}"

      - name: Build and install GKlib
        if: ${{ runner.os == 'Linux' && env.USE_MFEM == 'true' }}
        run: |
          set -eux
          cd "${GKLIB_SRC}"

          # Configure GKlib build; install into GKLIB_PREFIX
          make config \
            prefix="${CHESS_STACK_PREFIX}" \
            cc=mpicc

          make -j"$(nproc || echo 2)"
          make install

          # Wire GKlib into the environment
          echo "GKLIB_DIR=${CHESS_STACK_PREFIX}" >> "$GITHUB_ENV"

      - name: Clone METIS
        if: ${{ runner.os == 'Linux' && env.USE_MFEM == 'true' }}
        run: |
          set -eux
          git clone https://github.com/KarypisLab/METIS.git "${METIS_SRC}"
          cd "${METIS_SRC}"
          # Pin specific tag here, e.g. v5.2.1
          # git checkout v5.2.1

      - name: Build and install METIS
        if: ${{ runner.os == 'Linux' && env.USE_MFEM == 'true' }}
        run: |
          set -eux
          cd "${METIS_SRC}"

          make config \
            prefix="${CHESS_STACK_PREFIX}" \
            cc=mpicc \
            shared=0 \
            gklib_path="${CHESS_STACK_PREFIX}"

          make -j"$(nproc || echo 2)"
          make install

          echo "METIS_DIR=${CHESS_STACK_PREFIX}" >> "$GITHUB_ENV"

      - name: Clone hypre
        if: ${{ runner.os == 'Linux' && env.USE_MFEM == 'true' }}
        run: |
          set -eux
          # Pin version here
          HYPRE_REF="v2.32.0"
          git clone https://github.com/hypre-space/hypre.git "${HYPRE_SRC}"
          cd "${HYPRE_SRC}"
          git checkout "${HYPRE_REF}"

      - name: Build and install hypre (CMake, MPI)
        if: ${{ runner.os == 'Linux' && env.USE_MFEM == 'true' }}
        run: |
          set -eux

          mkdir -p "${HYPRE_BUILD}" "${CHESS_STACK_PREFIX}"

          cmake -S "${HYPRE_SRC}/src" -B "${HYPRE_BUILD}" \
            -G Ninja \
            -DCMAKE_BUILD_TYPE="${CMAKE_BUILD_TYPE}" \
            -DCMAKE_INSTALL_PREFIX="${CHESS_STACK_PREFIX}" \
            -DHYPRE_WITH_MPI=ON \
            -DHYPRE_ENABLE_SHARED=ON \
            -DHYPRE_WITH_OPENMP=OFF

          cmake --build "${HYPRE_BUILD}" \
            --config "${CMAKE_BUILD_TYPE}" \
            --target install -- -j"$(nproc || echo 2)"

          echo "HYPRE_DIR=${CHESS_STACK_PREFIX}" >> "$GITHUB_ENV"

      - name: Clone MFEM
        if: ${{ runner.os == 'Linux' && env.USE_MFEM == 'true' }}
        run: |
          set -eux
          # Pin version if needed: here (v4.4 from the advice)
          MFEM_VERSION=v4.8
          git clone --depth 1 --branch "${MFEM_VERSION}" https://github.com/mfem/mfem.git "${MFEM_SRC}"

      - name: Get MFEM commit hash
        if: ${{ runner.os == 'Linux' && env.USE_MFEM == 'true' }}
        id: mfemsha
        run: |
          set -eux
          cd "${MFEM_SRC}"
          echo "mfem_sha=$(git rev-parse HEAD)" >> "$GITHUB_OUTPUT"

      - name: Cache MFEM build
        if: ${{ runner.os == 'Linux' && env.USE_MFEM == 'true' }}
        id: cache-mfem
        uses: actions/cache@v4
        with:
          path: ${{ env.MFEM_BUILD }}
          key: ${{ runner.os }}-mfem-${{ steps.mfemsha.outputs.mfem_sha }}-${{ env.BUILD_NAME }}-${{ env.CMAKE_BUILD_TYPE }}

      - name: Build & install MFEM (MPI + HYPRE + METIS + ADIOS2 + SUNDIALS)
        if: ${{ runner.os == 'Linux' && env.USE_MFEM == 'true' }}
        run: |
          set -eux

          mkdir -p "${MFEM_BUILD}" "${CHESS_STACK_PREFIX}"
          if [ ! -f "${MFEM_BUILD}/CMakeCache.txt" ]; then
            cmake -S "${MFEM_SRC}" -B "${MFEM_BUILD}" \
              -G Ninja \
              -DCMAKE_BUILD_TYPE="${CMAKE_BUILD_TYPE}" \
              -DCMAKE_INSTALL_PREFIX="${CHESS_STACK_PREFIX}" \
              -DMFEM_INSTALL_EXAMPLES=YES \
              -DMFEM_USE_MPI=YES \
              -DMFEM_USE_LAPACK=YES \
              -DMFEM_DEBUG=NO \
              -DMFEM_USE_METIS_5=YES \
              -DMFEM_USE_ADIOS2=YES \
              -DMFEM_USE_SUNDIALS=YES
          fi

          cmake --build "${MFEM_BUILD}" \
            --config "${CMAKE_BUILD_TYPE}" \
            --target install -- -j"$(nproc || echo 2)"

      - name: Configure MFEM environment
        if: ${{ runner.os == 'Linux' && env.USE_MFEM == 'true' }}
        run: |
          set -eux
          echo "MFEM_DIR=${CHESS_STACK_PREFIX}" >> "$GITHUB_ENV"

      - name: Package dependency stack artifacts (${{ env.BUILD_NAME }})
        run: |
          set -eux

          STACK_DIR="${CHESS_STACK_PREFIX}"
          STACK_ROOT="$(dirname "${STACK_DIR}")"
          STACK_NAME="$(basename "${STACK_DIR}")"
          tar -C "${STACK_ROOT}" -czf "deps-${BUILD_NAME}.tar.gz" "${STACK_NAME}"

      - name: Upload dependency stack artifact (${{ env.BUILD_NAME }})
        uses: actions/upload-artifact@v4
        with:
          name: deps-${{ env.BUILD_NAME }}
          path: deps-${{ env.BUILD_NAME }}.tar.gz
